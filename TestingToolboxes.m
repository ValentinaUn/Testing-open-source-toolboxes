clear; close all; clc; % clean and close everything

%{
Notes:
% 1 before proceeding to the next sections make sure that the paths to 
% all the corresponding toolboxes are set (as well as path to the Data folder). 
% Toolboxes used in each section are specified in brackets after the section name
% 2 each section of code is independent and can be run separately
% 3 PerichReachData.mat contains same data as MM_S1_raw.mat but
% 1ms bin size 1ms instead of 10 ms: PerichReachData.mat data was 
% generated by running clean_data.m from
% https://crcns.org/data-sets/motor-cortex/pmd-1/about-pmd-1 (data and scripts)
% for dt = 0.001 instead of dt = 0.01 (line 24)
%}

%% 2.1.1 PSTH and raster plot for same neurons (FieldTrip, gramm, Chronux)

clear
nRuns = 1; % increase nRuns to average plotting times over more runs
load( 'PerichReachData.mat' );
binSize        = 0.05; % bin size is 50 ms=0.05s
timeSegment    = [ 0.0 1.0 ]; % analyze the first second
unitsSelection = [ 6 14 42 ]; % selection of M1 units to analyze
nUnits         = length( unitsSelection );
nTrials        = 498;         % number of trials
fontSize       = 24;
% we select trials longer than 1 second
[ spikeData, newNumbers ] = ...
    convertToFieldTrip( Data, 'M1', unitsSelection, nTrials, timeSegment );

% 2.1 FieldTrip and gramm: PSTH and raster plot (Figure 1)
cfg             = [];
cfg.binsize     = binSize; % in seconds
cfg.latency     = timeSegment;
cfg.outputunit  = 'rate';
cfg.trials      = find( newNumbers == 2 ); % consider every second reach 
psthFieldTrip   = ft_spike_psth( cfg, spikeData );

cfg             = [];
cfg.cmapneurons = [ 0.1725 0.6275 0.1725; 0.1216 0.4667 0.7059; ...
                    1.0000 0.4980 0.0549 ]; % set colormap
cfg.latency     = timeSegment; % in seconds
cfg.linewidth   = 2;
cfg.topplotfunc = 'line'; % plot as a line
cfg.trials      = find( newNumbers == 2 ); % consider every second reach 

compTime = zeros( 1, 2 );
figure;
subplot( 1, 2, 1 );
tic;
for iRuns = 1:nRuns
  ft_spike_plot_raster( cfg, spikeData, psthFieldTrip );
  set( gca, 'fontSize', 24 );
  legend( 'Unit6', 'Unit14', 'Unit42' );
end
compTime( 1 ) = toc/nRuns;
title( [ '(A) FieldTrip, plotting time ' num2str( compTime( 1 ), '%.2f') ' s' ] );

% data conversion for gramm
trialCnt       = 1; % counter of trials longer than 1 second
minTrialLength = 1000;
for iUnit = 1:nUnits
  % we take only trials corresponding to movement to the second trial
  for iTrial = 2:4:nTrials
    % take only trials longer than 1s
    if ( size( Data.neural_data_M1{ iTrial }( unitsSelection( iUnit ), : ), 2 ) > minTrialLength )
      spikeTimes = find( Data.neural_data_M1{ iTrial }( unitsSelection( iUnit ), 1:minTrialLength ) > 0 )/1000;
      grammSpikeData{ trialCnt } = spikeTimes;
      temp = histc( spikeTimes, 0:binSize:1.0 );
      binned{ trialCnt } = temp( 1:end-1 )/binSize;
      % we set here bin centers
      bins{ trialCnt }        = 0.025:binSize:0.975;
      colorValues{ trialCnt } = [ 'Unit' num2str( unitsSelection( iUnit ) ) ];
      trialCnt                = trialCnt + 1;
    end
  end
end

columnNumber = 2;
firstIndex   = 1;
secondIndex  = 2;
verticalLine = 0.325;
for iRuns = 1:nRuns
  clear g
  tic;
  g( firstIndex, columnNumber ) = gramm( 'x', bins, 'y', binned, 'color', colorValues );
  g( firstIndex, columnNumber ).stat_summary( 'setylim', true, 'type', 'sem' );
  g( firstIndex, columnNumber ).geom_vline( 'xintercept', verticalLine );
  g( firstIndex, columnNumber ).set_line_options( 'base_size', 4 );
  g( firstIndex, columnNumber ).set_names( 'x', '', 'y', 'Rate [Hz]' );

  g( secondIndex, columnNumber ) = gramm( 'x', grammSpikeData, 'color', colorValues );
  g( secondIndex, columnNumber ).geom_raster( 'geom', 'point' );
  g( secondIndex, columnNumber ).geom_vline( 'xintercept', verticalLine );
  g( secondIndex, columnNumber ).set_line_options( 'base_size', 4 );
  g( secondIndex, columnNumber ).set_names( 'x', 'Time [s]', 'y', 'Trials' );
  g( secondIndex, columnNumber ).set_layout_options( 'legend', 'false' );

  g.set_text_options( 'base_size', fontSize );
  g.set_color_options( 'map', 'd3_20' );
  g.set_point_options( 'base_size', 4 );
  g.set_line_options( 'base_size', 4 );
  % as actual drawing happens after setting the title, the computing time
  % is set as constant here, but it follows from theexperiments
  g.set_title( '(B) gramm, plotting time 0.54s' );
  g.draw();
  compTime( 2 ) = compTime( 2 ) + toc;
end
compTime( 2 ) = compTime( 2 )/nRuns;

% PSTH by Chronux
figure;
unitNumber = 6;
trialCnt   = 1;
for iTrial = 2:4:nTrials
    % spike times in seconds       
    if ( size( Data.neural_data_M1{ iTrial }( unitNumber, : ), 2 ) > minTrialLength )
      chrSpikes( trialCnt ).times = ...
        find( Data.neural_data_M1{ iTrial }( unitNumber, 1:minTrialLength ) > 0 )/minTrialLength; 
      trialCnt = trialCnt + 1;
    end
end

clear psth % clear variable with the same name as Chronux function
[ firingRate, spikeTimes, statErrors ] = ...
                       psth( chrSpikes, binSize, 'r', timeSegment, 1 ); 
legend( 'Unit 6' );                     
set( gca, 'FontSize', fontSize );
title( 'Chronux: PSTH' );

%% 2.1.2 ISI (inter-spike-interval) distribution (FieldTrip)

clear
load( 'PerichReachData.mat' );
timeSegment    = [ 0 1.0 ];
unitsSelection = 14;
nTrials        = 489;
spikeData = convertToFieldTrip( Data, 'M1', unitsSelection, nTrials, timeSegment );
nTrials   = size( spikeData.trialtime, 1 );

cfg        = [];
cfg.bins   = 0:0.005:0.1; % use bins of 0.5 milliseconds
cfg.param  = 'coeffvar'; % compute the coefficient of variation (sd/mn of isis)
cfg.trials = 1:4:nTrials;
isih       = ft_spike_isi( cfg, spikeData );

figure;
cfg              = [];
cfg.spikechannel = isih.label{ 1 };
cfg.interpolate  = 5; % interpolate at 5 times the original density
cfg.window       = 'gausswin'; % use a gaussian window to smooth
cfg.winlen       = 0.004;      % the smoothing window has size 4 by 4 ms
cfg.colormap     = parula;     % colormap
cfg.scatter      = 'no'; % do not plot the individual isis per spike as scatters
ft_spike_plot_isireturn( cfg, isih );
title( '(A) FieldTrip' );
caxis( [ 0 4 ] );
set( gca, 'FontSize', 24 ); 

% for Spike Viewer ISIH, use SpikeViewer GUI for test dataset:
% from https://spyke-viewer.readthedocs.io/en/latest/usage.html#loading-data
% Tetrode 1(A-a), all channels selected, all segments selected, unit 2 (A-a-1)

%% 2.2.1 Unique tools: locfit (Chronux)

clear
load( 'MM_S1_raw.mat' );
nTrials = 140;
% compute PSTH with Chronux
figure;
binSize = 0.05; % in seconds
timeInterval = [ 0.0 4.0 ];
unitNumber = 6;
for iTrial = 1:nTrials
    spikeTimes = ( M1.units( unitNumber ).ts > trial_table( iTrial, 3 ) & ...
                   M1.units( unitNumber ).ts < trial_table( iTrial, 22 ) );
    % spike times in seconds          
    spikeData( iTrial ).times = ...
      ( M1.units( unitNumber ).ts( spikeTimes ) - trial_table( iTrial, 1 ) ); 
    spikeData( iTrial ).times = ...
            spikeData( iTrial ).times( spikeData( iTrial ).times < timeInterval( 2 ) );
end
[ firingRate, spikeTimes, statErrors ] = ...
                          psth( spikeData, binSize, 'r', timeInterval, 1 ); 
set( gca, 'FontSize', 24 );
title( 'Chronux: PSTH' );

trialNumber = 1;
figure;
subplot( 1, 2, 1 );
h = histogram( spikeData( trialNumber ).times );
h.BinWidth = 0.2;
set( gca, 'FontSize', 24 );
ylabel( 'Counts' );
title( 'Frequency histogram' );

subplot( 1, 2, 2 );
fit = locfit( spikeData( trialNumber ).times', 'family', 'rate', 'nn', 0.7 );
lfplot( fit );
lfband( fit );
set( gca, 'FontSize', 24 );
xlabel( 'Time [s]' );
ylabel( 'Rate [Hz]' );
title( 'Smoothed spike rate for 1 trial ');

%% 2.2.2.1 Unique tools: spectrum and spectogram for point-processes (Chronux)
% spectrogram averaged across trials

clear
load( 'MM_S1_raw.mat' );

figure;
params.tapers = [ 5 9 ];   % 10 - time-bandwidth product, 19 - number of tapers
params.err    = 0;         % no error computation
params.fpass  = [ 0 100 ]; % interval of frequencies of interest
params.Fs     = 1000;      % sampling rate
params.trialave = 1; 
movingWin     = [ 0.5 0.05 ]; % moving windows in seconds [ size step ]

iTrial  = 49;
cnt     = 1;
for iUnit = [ 39 44 ]
  % from movement onset till the end of trial
  clear spikeData
  % spike times in seconds   
  trialCnt = 1;
  minTrialLength = 2.8;
  for iTrial = 1:140
    if ( trial_table( iTrial, 22 ) - trial_table( iTrial, 3 ) > minTrialLength )
      spikeTimes = ( M1.units( iUnit ).ts > trial_table( iTrial, 3 ) & ...
                     M1.units( iUnit ).ts < trial_table( iTrial, 3 ) + minTrialLength );
      spikeData( trialCnt ).times = ( M1.units( iUnit ).ts( spikeTimes ) - trial_table( iTrial, 3 ) )';
      trialCnt = trialCnt + 1;
    end
  end
  subplot( 1, 2, cnt );
  cnt = cnt + 1;
  [ spectrumValues, cTimeValues, freqValues, rateValues ] = ...
              mtspecgrampt( spikeData, movingWin, params );
  spectrumValues = spectrumValues/max( max( spectrumValues ) );
  colormap parula;
  imagesc( cTimeValues', freqValues', 10*log10( spectrumValues' ) );
  hc = colorbar;
  title( hc, 'dB/Hz' );
  caxis( [ -4 0 ] );
  axis xy; % flip axis
  set( gca, 'FontSize', 24 );
  xlabel( 'Time [s]' );
  if ( iUnit == 14 )
    ylabel( 'Freq [Hz]' );
  end
  title( [ 'Spectogram, ' num2str( iTrial ) ' trial, M1 unit ' ...
                                                    num2str( iUnit ) ] );
end

%% 2.2.2.2 Unique tools: spectrum and spectogram for point-processes (Chronux)
% spectrogram for 1 trial

clear
load( 'MM_S1_raw.mat' );

figure;
params.tapers = [ 10 19 ]; % 10: time-bandwidth product, 19: number of tapers
params.err    = 0;         % no error computation
params.fpass  = [ 0 100 ]; % interval of frequencies of interest
params.Fs     = 1000;      % sampling rate
params.trialave = 1;  
movingWin     = [ 0.8 0.05 ]; % moving windows in seconds [ size step ]

iTrial  = 3; 
cnt     = 1;
for iUnit = [ 14 17 ]
  % from movement onset till the end of trial
  clear spikeData
  spikeTimes = ( M1.units( iUnit ).ts > trial_table( iTrial, 3 ) & ...
                 M1.units( iUnit ).ts < trial_table( iTrial, 22 ) );
  % spike times in seconds          
  spikeData( 1 ).times = ...
      ( M1.units( iUnit ).ts( spikeTimes ) - trial_table( iTrial, 1 ) ); 
  subplot( 1, 2, cnt );
  cnt = cnt + 1;
  [ spectrumValues, cTimeValues, freqValues, rateValues ] = ...
              mtspecgrampt( spikeData, movingWin, params );
  colormap parula;
  imagesc( cTimeValues', freqValues', 10*log10( spectrumValues' ) );
  hc = colorbar;
  title( hc, 'dB/Hz' );
  caxis( [ 0 20 ] );
  axis xy; % flip axis
  set( gca, 'FontSize', 24 );
  xlabel( 'Time [s]' );
  if ( iUnit == 14 )
    ylabel( 'Freq [Hz]' );
  else
    set( gca, 'YTickLabel', [] );
  end
  title( [ 'Spectogram, ' num2str( iTrial ) ' trial, M1 unit ' ...
                                                      num2str( iUnit ) ] );
end

%% 3.1.1 Line Noise Removal (MATLAB, Brainstorm, Chronux, FieldTrip)

% ! to run this section, exclude from the MATLAB path the folder
% fieldtrip/external/signal (due to the name conflict) !
clear
load openloop60hertz 
noisyData = openLoopVoltage;
nRuns     = 1; % increase nRuns to average computing times for more runs
Fs        = 1000;
timeValues = ( 0:length( noisyData ) - 1 )/Fs;
filterDesigned = designfilt( 'bandstopiir', 'FilterOrder', 2, ...
                'HalfPowerFrequency1', 59, 'HalfPowerFrequency2', 61, ...
                'DesignMethod', 'butter', 'SampleRate', Fs );
              
% MATLAB filtering
tic;
for iRun = 1:nRuns
  matlabFilt = filtfilt( filterDesigned, noisyData );
end
filtTime( 1 ) = toc/nRuns;

% Chronux filtering
params.tapers = [ 3 5 ];
params.Fs     = Fs;
tic;
for iRun = 1:nRuns
  chronuxFilt = rmlinesc( noisyData, params, 0.05, 'n', 60 );
end
filtTime( 2 ) = toc/nRuns;

% FieldTrip filtering with dft
tic;
for iRun = 1:nRuns
  fieldtripFilt = ft_preproc_dftfilter( noisyData', 1000, 60, ...
                                                    'Flreplace', 'zero' );
end
filtTime( 3 ) = toc/nRuns;

% Brainstorm filtering (this code has been copied from 
% process_notch function, lines 104-139, Brainstorm toolbox v3.4)
tic;
for iRun = 1:nRuns
    x = noisyData';
    FreqList = 60.0;
    FreqWidth = 1;
    sfreq     = Fs;
    UseSigProcToolbox = 1;
    % Remove the mean of the data before filtering
    xmean = mean(x,2);
    x = bst_bsxfun(@minus, x, xmean);
    % Remove all the frequencies sequencially
    for ifreq = 1:length(FreqList)
        % Define coefficients of an IIR notch filter
        delta = FreqWidth/2;
        % Pole radius
        r = 1 - (delta * pi / sfreq);     
        theta = 2 * pi * FreqList(ifreq) / sfreq;
        % Gain factor
        B0 = abs(1 - 2*r*cos(theta) + r^2) / (2*abs(1-cos(theta)));   
        % Numerator coefficients
        B = B0 * [1, -2*cos(theta), 1];  
        % Denominator coefficients
        A = [1, -2*r*cos(theta), r^2];    
        % Filter signal
        if UseSigProcToolbox
            x = filtfilt( B,A,x')'; 
        else
            x = filter( B,A,x')'; 
            x(:,end:-1:1) = filter(B,A,x(:,end:-1:1)')'; 
        end
    end
    % Restore the mean of the signal
    brainstormFilt = bst_bsxfun(@plus, x, xmean);
end
filtTime( 4 ) = toc/nRuns;
filtTime = filtTime*1000;

timeInt = 1:800;
figure;
fontSize = 24;
subplot( 3, 4, 1 );
plot( timeValues( timeInt ), noisyData( timeInt ), ...
  timeValues( timeInt ), matlabFilt( timeInt ), 'LineWidth', 2 );
%set( gca, 'XTick', [] );
xlabel( 'Time (s)' );
ylabel( 'Voltage (V)' );
legend( 'Unfiltered', 'MATLAB filtered' );
title( '(A) Open-Loop Voltage' );
axis tight
grid on
set( gca, 'FontSize', fontSize );

subplot( 3, 4, 2 );
plot( timeValues( timeInt ), noisyData( timeInt ), ...
  timeValues( timeInt ), chronuxFilt( timeInt ), 'LineWidth', 2 );
xlabel( 'Time (s)' );
legend( 'Unfiltered', 'Chronux filtered' );
axis tight
grid on
set( gca, 'FontSize', fontSize );

subplot( 3, 4, 3 );
plot( timeValues( timeInt ), noisyData( timeInt ), ...
  timeValues( timeInt ), fieldtripFilt( timeInt ), 'LineWidth', 2 );
xlabel( 'Time (s)' );
legend( 'Unfiltered', 'FieldTrip filtered' );
axis tight
grid on
set( gca, 'FontSize', fontSize );

subplot( 3, 4, 4 );
plot( timeValues( timeInt ), noisyData( timeInt ), ...
  timeValues( timeInt ), brainstormFilt( timeInt ), 'LineWidth', 2 );
legend( 'Unfiltered', 'Brainstorm filtered' );
xlabel( 'Time (s)' );
axis tight
grid on
set( gca, 'FontSize', fontSize );

[ pOriginal, fOriginal ]     = periodogram( noisyData, [], [], Fs );
[ pMATLAB, fMATLAB ]         = periodogram( matlabFilt, [], [], Fs );
[ pChronux, fChronux ]       = periodogram( chronuxFilt, [], [], Fs );
[ pFieldTrip, fFieldTrip ]   = periodogram( fieldtripFilt, [], [], Fs );
[ pBrainstorm, fBrainstorm ] = periodogram( brainstormFilt, [], [], Fs );

subplot( 3, 4, 5 );
% *20 because of power transfer, P = UxI=U^2/R, T = 10log(P_out/P_in)=10log()
%https://www.physicsforums.com/threads/confusion-with-db-equation-10-or-20.641850/
freqToPlot = 50:206; % indices for frequencies to plot
plot( fOriginal( freqToPlot ), 20*log10( abs( pOriginal( freqToPlot ) ) ), ...
      fOriginal( freqToPlot ), 20*log10( abs( pMATLAB( freqToPlot ) ) ), ...
                                                      '--', 'LineWidth', 2 );
legend( 'Unfiltered', [ 'MATLAB filtered, ' num2str( filtTime( 1 ), '%.2f' ) 'ms' ] );
title( '(B) Power Spectrum' );
xlabel( 'Frequency (Hz)' );
set( gca, 'FontSize', fontSize );
ylabel( 'Power/frequency (dB/Hz)' );
axis tight
grid on
ylim( [ -120 20 ] );

subplot( 3, 4, 6 );
plot( fOriginal( freqToPlot ), 20*log10( abs( pOriginal( freqToPlot ) ) ), ...
      fOriginal( freqToPlot ), 20*log10( abs( pChronux( freqToPlot ) ) ), ...
      '--', 'LineWidth', 2  );
%set( gca, 'XTick', [] );
legend( 'Unfiltered', ['Chronux filtered, ' num2str( filtTime( 2 ), '%.2f') 'ms' ] );
set( gca, 'FontSize', fontSize );
xlabel( 'Frequency (Hz)' );
axis tight
grid on
ylim( [ -120 20 ] );

subplot( 3, 4, 7 );
plot( fOriginal( freqToPlot ), 20*log10( abs( pOriginal( freqToPlot ) ) ), ...
      fOriginal( freqToPlot ), 20*log10( abs( pFieldTrip( freqToPlot ) ) ), ...
      '--', 'LineWidth', 2  );
%set( gca, 'XTick', [] );
legend( 'Unfiltered', [ 'FieldTrip filtered, ' num2str( filtTime( 3 ), '%.2f') 'ms' ] );
set( gca, 'FontSize', fontSize );
xlabel( 'Frequency (Hz)' );
axis tight
grid on
ylim( [ -120 20 ] );

subplot( 3, 4, 8 );
plot( fOriginal( freqToPlot ), 20*log10( abs( pOriginal( freqToPlot ) ) ), ...
      fOriginal( freqToPlot ), 20*log10( abs( pBrainstorm( freqToPlot ) ) ), ...
      '--', 'LineWidth', 2  );
legend( 'Unfiltered', [ 'Brainstorm filtered, ' num2str( filtTime( 4 ), '%.2f' ) 'ms' ] );
xlabel( 'Frequency (Hz)' );
set( gca, 'FontSize', fontSize );
axis tight
grid on
ylim( [ -120 20 ] );

pOriginal   = 20*log10( abs( pOriginal ) );
pMATLAB     = 20*log10( abs( pMATLAB ) );
pChronux    = 20*log10( abs( pChronux ) );
pFieldTrip  = 20*log10( abs( pFieldTrip ) );
pBrainstorm = 20*log10( abs( pBrainstorm ) );

MSE = zeros( 1, 4 );
% we exclude point in the 0.2 vicinity of 60Hz
for iFreq = [ 1:123 125:length( fOriginal ) ]
  MSE( 1 ) = MSE( 1 ) + ( pMATLAB( iFreq ) - pOriginal( iFreq ) )^2;
  MSE( 2 ) = MSE( 2 ) + ( pChronux( iFreq ) - pOriginal( iFreq ) )^2;
  MSE( 3 ) = MSE( 3 ) + ( pFieldTrip( iFreq ) - pOriginal( iFreq ) )^2;
  MSE( 4 ) = MSE( 4 ) + ( pBrainstorm( iFreq ) - pOriginal( iFreq ) )^2;
end
MSE( : ) = MSE( : )/( length( fOriginal ) - 2 );

subplot( 3, 1, 3 );
hBar = bar( MSE );
hBar.FaceColor = [ 0 0.4470 0.7410 ];
set( gca, 'XTickLabel', {'MATLAB', 'Chronux', 'FieldTrip', 'Brainstorm' } );
ylabel( 'MSE' );
grid on;
title( '(C) Mean-squared error' );
set( gca, 'FontSize', 24 );

%% 3.1.2 detrending (Brainstorm, Chronux, FieldTrip)

clear
nRuns        = 1; % increase nRuns to average detrending times for more runs
timeValues   = 0:300;
dailyFluct   = gallery( 'normaldata', size( timeValues ), 2 ); 
originalData = cumsum( dailyFluct ) + 20 + timeValues/100;

figure;
plot( timeValues, originalData, 'LineWidth', 2 );
legend( 'Original Data', 'Location', 'northwest' );
xlabel( 'Time (days)' );
ylabel( 'Stock Price (dollars)' );

tic
for iRun = 1:nRuns 
  matlabDetrend = detrend( originalData );
end
compTime( 1 ) = toc/nRuns;

tic
for iRun = 1:nRuns
  chronuxDetrend = locdetrend( originalData );
end
compTime( 2 ) = toc/nRuns;

tic
for iRun = 1:nRuns
  fieldtripDetrend = ft_preproc_detrend( originalData, 1, length( originalData ) );
end
compTime( 3 ) = toc/nRuns;

% Brainstorm v3.4 detrend from process_detrend function, lines 116-128
iTime = [];
tic
for iRun = 1:nRuns
    % Number of samples
    nTime = size( originalData, 2 );
    % Parse inputs
    if isempty(iTime)
        iTime = 1:nTime;
    end
    % Basis functions
    x = [ones(1,nTime); 0:nTime-1];
    invxcov = inv(x(:,iTime) * x(:,iTime)');
    beta    = originalData(:,iTime) * x(:,iTime)' * invxcov;
    % Remove the estimated basis functions
    brainstormDetrend = originalData - beta*x;
end
compTime( 4 ) = toc/nRuns;

hold on
plot( timeValues, originalData - matlabDetrend, ':', 'LineWidth', 2 );
plot( timeValues, originalData - chronuxDetrend', ':', 'LineWidth', 2 );
plot( timeValues, originalData - fieldtripDetrend, ':', 'LineWidth', 2 );
plot( timeValues, originalData - brainstormDetrend, ':', 'LineWidth', 2 );
plot( timeValues, matlabDetrend, 'LineWidth', 2 );
plot( timeValues, chronuxDetrend, 'LineWidth', 2 );
plot( timeValues, fieldtripDetrend, 'LineWidth', 2 );
plot( timeValues, brainstormDetrend, 'LineWidth', 2 );
plot( timeValues, zeros( size( timeValues ) ), ':k', 'LineWidth', 2 );
legend( 'Original Data', 'Trend MATLAB', 'Trend Chronux', ...
  'Trend FieldTrip', 'Trend Brainstorm', 'Detrended data MATLAB', ...
  'Detrended data Chronux', 'Detrended data FieldTrip', ...
  'Detrended data Brainstorm', 'Mean of Detrended Data', 'Location', 'northwest' );
xlabel( 'Time (days)' ); 
ylabel( 'Stock Price (dollars)' );
set( gca, 'FontSize', 24 );

%% 3.1.3 spectogram of 1 trial (MATLAB, Brainstorm, Chronux, Elephant, FieldTrip)

clear
freqOfInterest = 1.9531:1.9531:80.0;
fSample        = 1000; % sampling frequency
nRuns          = 1; % increase nRuns to average spectra estimating times over more runs
plotXlim       = [ 0.5 3.5 ]; % plot spectra values from 0.5 to 3.5 seconds
timeSegment    = [ 0.0 4.0 ]; % time segment in seconds
nPoints        = 4001;
lfpTimeSegment = 1:nPoints; % in time points from -1 to 1 seconds
movingWindow   = 512; % 512ms = 512 points
windowStep     = 1;   % in points: 50ms = 50 points
winOverlap     = 511; % maximal overlap for windows
minDb          = -40;
colorbarLim    = [ minDb 0 ];
timeValues     = timeSegment( 1 ):0.001:timeSegment( end );
modFreq        = [ 40 60 8 20 ];
fm             = 2.0; 
fc             = 40.0;
mi             = 6.0;         

% prepare FieldTrip structure
lfpData.fSample = fSample;
lfpData.trial      = cell( 1, 1 );
lfpData.time       = cell( 1, 1 );
lfpData.label{ 1 } = 'simulated_data';
  
% data in additiveNoise.mat were generated as additiveNoise = randn( 1, 2001 );
% and saved in mat file for repeatability of the results
load( 'additiveNoise.mat' );
plotIndices = [ 1 3 5 7 9 11 13 15 2 4 6 8 10 12 14 16 17 18 ];
figure;
nPlot = 1;
chronuxTapers = 1;
estFreq    = cell( 1, 16 );
estSpectra = cell( 1, 16 );
for iPlot = 1:2
  if ( iPlot == 1 )
    ftMorletWidth         = 20; % width of wavelet in number of cycles
    ftSpectralSmoothing   = 2;  % amount of spectral smoothing +-2Hz
    % sliding window in seconds for each frequency
    ftSlidingWindow       = repmat( movingWindow/fSample, length( freqOfInterest ) );
    chronuxTbwProduct     = 2;  % time band-width product
    brainstromCentralFreq = 4.0;
    dataValues( 1:4001 ) = ...
      sin( 2*pi*modFreq( 1 )*timeValues ) + sin( 2*pi*modFreq( 2 )*timeValues ) + ...
      sin( 2*pi*modFreq( 3 )*timeValues ) + sin( 2*pi*modFreq( 4 )*timeValues );
  else
    ftMorletWidth         = 10; % width of wavelet in number of cycles
    % amount of spectral smoothing +-0.1F at each frequency F
    ftSpectralSmoothing   = 0.1*freqOfInterest;
    % sliding window in seconds for each frequency: 8/F at each F
    ftSlidingWindow       = 8./freqOfInterest;
    chronuxTbwProduct     = 8; % time bandwidth product in Chronux
    brainstromCentralFreq = 1.5;
    dataValues( 1:4001 ) = cos( 2*pi*fc*timeValues + ( mi*sin( 2*pi*fm*timeValues ) ) );
  end
  % compute signal to noise ratio
  SNR( iPlot )           = snr(  dataValues( 2001:end ), additiveNoise );
  dataValues( 2001:end ) = dataValues( 2001:end ) + additiveNoise;
  lfpData.trial{ 1 }( lfpTimeSegment ) = dataValues;
  lfpData.time{ 1 }( lfpTimeSegment )  = timeValues;
  
  % save data for Elephant
  save( [ 'sines' num2str( iPlot ) '.mat' ], 'dataValues' );

  % Brainstorm Morlet wavelet transform (with default central frequency)
  subplot( 5, 4, plotIndices( nPlot ) );
  nPlot = nPlot + 1;
  tic; % loop to measure computing time
  for iRun = 1:nRuns
    coefsBrainstorm = morlet_transform( dataValues, timeValues, ...
                          freqOfInterest, brainstromCentralFreq, [], 'y' );
  end
  specTime( 5 ) = toc;
  coefsBrainstorm = coefsBrainstorm/max( max( coefsBrainstorm ) );
  coefsBrainstorm = 10*log10( squeeze( coefsBrainstorm )' );
  coefsBrainstorm( coefsBrainstorm < minDb ) = minDb;
  estSpectra{ nPlot - 1 } = coefsBrainstorm;
  imagesc( timeValues, 2:2:80, coefsBrainstorm );
  axis xy; % flip axis
  caxis( colorbarLim );
  xlim( plotXlim );
  set( gca, 'XTick', [] );
  if ( iPlot == 1 )
    ylabel( 'Freq [Hz]' );
    title( [ '(A) Brainstorm: Morlet wavelet ' ...
                            num2str( specTime( 5 )/nRuns, '%.2f' ) 's' ] );
  else
    set( gca, 'YTick', [] );
  end
  set( gca, 'FontSize', 24 );
  
  % Chronux multi-taper time-frequency transform
  subplot( 5, 4, plotIndices( nPlot ) );
  nPlot         = nPlot + 1;
  params.tapers = [ chronuxTbwProduct chronuxTapers ]; % taper parameters
  params.fpass  = [ freqOfInterest( 1 ) - 0.5 freqOfInterest( end ) + 0.5 ];
  params.Fs     = fSample; % sampling Rate
  params.pad    = 0;       % padding type
  tic; % loop to measure computing time
  for iRun = 1:nRuns
    [ spectrumValues, cTimeValues, freqValues ] = ...
     mtspecgramc( dataValues', [ movingWindow windowStep ]/fSample, params );
  end
  specTime( 2 ) = toc;
  spectrumValues = spectrumValues/( max( max( spectrumValues ) ) );
  spectrumValues = 10*log10( spectrumValues );
  spectrumValues( spectrumValues < minDb ) = minDb;
  estFreq{ nPlot - 1 }    = freqValues;
  estSpectra{ nPlot - 1 } = spectrumValues';
  imagesc( ( cTimeValues )', freqValues', spectrumValues' );
  xlim( plotXlim );
  set( gca, 'XTick', [] );
  caxis( colorbarLim );
  set( gca, 'FontSize', 24 );
  set( gca, 'YTick', [] );
  set( gca, 'YDir', 'normal' );
  if ( iPlot == 1 )
    title( [ '(B) Chronux: multitapers dpss ' num2str( specTime( 2 )/nRuns, '%.2f' ) 's' ] );
  end
  
  % Elephant Morlet wavelets
  subplot( 5, 4, plotIndices( nPlot ) );
  nPlot = nPlot + 1;
  if ( iPlot == 1 )
    load( 'spectrSine1' );
  else 
    load( 'spectrSine2' );
  end
  powerValues = squeeze( abs( data ).^2 );
  powerValues = powerValues/max( max( powerValues ) );
  powerValues = 10*log10( powerValues );
  powerValues( powerValues < minDb ) = minDb;
  estSpectra{ nPlot - 1 } = powerValues;
  imagesc( timeValues, freqOfInterest, powerValues );
  axis xy; % flip axis
  caxis( colorbarLim );
  xlim( plotXlim );
  set( gca, 'XTick', [] );
  if ( iPlot == 1 )
    title( '(C) Elephant: Morlet wavelet 0.02s' );
    ylabel( 'Freq [Hz]' );
  else
    set( gca, 'YTick', [] );
  end
  set( gca, 'FontSize', 24 );
  
  % Fieldtrip multi-taper time-frequency transform with Slepian seuqences
  subplot( 5, 4, plotIndices( nPlot ) );
  nPlot         = nPlot + 1;
  cfg           = [];
  cfg.foi       = freqOfInterest; % frequencies of interest 
  cfg.method    = 'mtmconvol';    % multitaper time-frequency transformation
  cfg.output    = 'pow';
  cfg.taper     = 'dpss';         % with Slepian sequences
  cfg.tapsmofrq = ftSpectralSmoothing; % amount of spectral smoothing
  cfg.t_ftimwin = ftSlidingWindow; % sliding window in seconds
  cfg.pad       = 512;
  % times (in seconds) on which analysis windows should be centered
  cfg.toi       = timeSegment( 1 ):windowStep/fSample:timeSegment( 2 );
  cfg.trials    = 1;
  tic; % loop to measure computing time
  for iRun = 1:nRuns
    spectrumValues = ft_freqanalysis( cfg, lfpData );
  end
  specTime( 4 ) = toc;
  temp = spectrumValues.powspctrm/max( max( spectrumValues.powspctrm ) );
  spectrumValues.powspctrm = 10*log10(temp);
  spectrumValues.powspctrm( spectrumValues.powspctrm < minDb ) = minDb;
  estFreq{ nPlot - 1 }    = spectrumValues.freq;
  estSpectra{ nPlot - 1 } = squeeze( spectrumValues.powspctrm );
  cfg          = [];
  cfg.colorbar = 'no';
  cfg.title    = [];
  ft_singleplotTFR( cfg, spectrumValues );
  set( gca, 'XTick', [] );
  set( gca, 'YTick', [] );
  caxis( colorbarLim );
  colormap parula
  xlim( plotXlim );
  if ( iPlot == 1 )
    title( [ '(D) FieldTrip: multitapers dpss ' num2str( specTime( 4 )/nRuns, '%.2f' ) 's' ] );
  else
    title( '' );
  end
  set( gca, 'FontSize', 24 );

  % FieldTrip multitaper time-frequency transform with a Hanning window
  subplot( 5, 4, plotIndices( nPlot ) );
  nPlot         = nPlot + 1; 
  cfg           = [];
  cfg.foi       = freqOfInterest; % Freq Of Interest - analysis in steps of 2 Hz 
  cfg.method    = 'mtmconvol';    % time-frequency analysis using Morlet waveforms
  cfg.output    = 'pow';
  cfg.taper     = 'hanning';
  % length of sliding time window in seconds
  cfg.t_ftimwin = ftSlidingWindow;
  cfg.pad       = 512;
  % times on which analysis windows should be centered
  cfg.toi       = timeSegment( 1 ):windowStep/fSample:timeSegment( 2 );
  cfg.trials    = 1;
  tic; % loop to measure computing time
  for iRun = 1:nRuns
    spectrumValues = ft_freqanalysis( cfg, lfpData );
  end
  specTime( 3 ) = toc;
  temp = spectrumValues.powspctrm/max( max( spectrumValues.powspctrm ) );
  spectrumValues.powspctrm = 10*log10( temp );
  spectrumValues.powspctrm( spectrumValues.powspctrm < minDb ) = minDb;
  estFreq{ nPlot - 1 }    = spectrumValues.freq;
  estSpectra{ nPlot - 1 } = squeeze( spectrumValues.powspctrm );
  cfg          = [];
  cfg.colorbar = 'no';
  ft_singleplotTFR( cfg, spectrumValues );
  caxis( colorbarLim );
  xlim( plotXlim );
  set( gca, 'XTick', [] );
  if ( iPlot == 1 )
    ylabel( 'Freq [Hz]' );
    title( [ '(E) FieldTrip: multitapers Hanning ' ...
                            num2str( specTime( 3 )/nRuns, '%.2f' ) 's'] );
  else
    title( '' );
    set( gca, 'YTick', [] );
  end
  set( gca, 'FontSize', 24 );

  % FieldTrip Morlet wavelet transform 
  subplot( 5, 4, plotIndices( nPlot ) );
  nPlot = nPlot + 1;
  cfg           = [];
  cfg.foi       = freqOfInterest; % frequencies of interest
  cfg.method    = 'wavelet';      % time-frequency analysis using Morlet waveforms
  cfg.output    = 'pow';
  % times on which analysis windows should be centered
  cfg.toi       = timeSegment( 1 ):windowStep/fSample:timeSegment( 2 );
  cfg.trials    = 1;
  % standard parameters
  cfg.width     = ftMorletWidth;
  cfg.pad       = 512;
  %cfg.gwidth    = 3; % wavelet length in standard deviations of the implicit Gaussian kernel
  % loop to measure computing time
  tic;
  for iRun = 1:nRuns
    spectrumValues = ft_freqanalysis( cfg, lfpData );
  end
  specTime( 7 ) = toc;
  temp = spectrumValues.powspctrm/max( max( spectrumValues.powspctrm ) );
  spectrumValues.powspctrm = 10*log10( temp );
  spectrumValues.powspctrm( spectrumValues.powspctrm < minDb ) = minDb;
  estFreq{ nPlot - 1 }    = spectrumValues.freq;
  estSpectra{ nPlot - 1 } = squeeze( spectrumValues.powspctrm );
  cfg          = [];
  cfg.colorbar = 'no';
  ft_singleplotTFR( cfg, spectrumValues );
  caxis( colorbarLim );
  set( gca, 'XTick', [] );
  %xlabel( 'Time [s]' );
  xlim( plotXlim );
  set( gca, 'YTick', [] );
  if ( iPlot == 1 )
    title( [ '(F) FieldTrip: Morlet wavelet ' num2str( specTime( 7 )/nRuns, '%.2f' ) 's' ] );
  else
    title( '' );
  end
  set( gca, 'FontSize', 24 );
  
  subplot( 5, 4, plotIndices( nPlot ) );
  nPlot = nPlot + 1;
  tic; % loop to measure computing time
  for iRun = 1:nRuns
    [ spectrumValues, freqValues, mTimeValues, powerValues ] = ...
      spectrogram( dataValues, movingWindow, winOverlap, freqOfInterest, fSample, 'yaxis' );
  end
  specTime( 1 ) = toc;
  powerValues = powerValues/( max( max( powerValues ) ) );
  powerValues = 10*log10( powerValues );
  powerValues( powerValues < minDb ) = minDb;
  estFreq{ nPlot - 1 }    = freqValues;
  estSpectra{ nPlot - 1 } = powerValues;
  imagesc( mTimeValues, freqValues, powerValues );
  set( gca, 'XTick', [] );
  xlim( plotXlim );
  colormap parula
  axis xy; % flip axis
  caxis( colorbarLim );
  if ( iPlot == 1 )
    ylabel( 'Freq [Hz]' );
    title( [ '(G) MATLAB: short time FFT ' ...
                            num2str( specTime( 1 )/nRuns, '%.2f' ) 's' ] );
  else
    set( gca, 'YTick', [] );
  end
  set( gca, 'FontSize', 24 );
  
  % Morlet wavelet with MATLAB
  subplot( 5, 4, plotIndices( nPlot ) );
  nPlot = nPlot + 1;
  tic; % loop to measure computing time
  for iRun = 1:nRuns
    % Convert the scales to approximate frequencies in hertz for the Morlet wavelet
    convertedFrq = brainstromCentralFreq./freqOfInterest;
    scales = 6./( 2*pi*freqOfInterest );
    [ coefMatlab, freqMatlab ] = cwt( dataValues, scales, 'cmor1-1.5', 1/fSample );
  end
  specTime( 6 ) = toc;
  coefMatlab = abs( coefMatlab ).^2;
  coefMatlab = coefMatlab/max( coefMatlab );
  powerVaules = 10*log10( coefMatlab );
  powerValues( powerValues < minDb ) = minDb;
  estFreq{ nPlot - 1 }    = freqMatlab;
  estSpectra{ nPlot - 1 } = powerValues;
  imagesc( mTimeValues, freqMatlab, powerValues );
  axis xy
  xlabel( 'Time [s]' );
  caxis( colorbarLim );
  xlim( plotXlim );
  set( gca, 'YTick', [] );
  if ( iPlot == 1 )
    title( [ '(H) MATLAB: Morlet wavelet ', num2str( specTime( 6 )/nRuns, '%.2f' ) 's' ] );
  end
  set( gca, 'FontSize', 24 );
end

% now compare quantitatevly estimated with ideal spectra
idealSpectrumX1 = zeros( 80, nPoints ) - 40;
% we allow bandwidth +-1 Hz
idealSpectrumX1( [ 7:9 19:21 39:41 59:61 ], : ) = 0;
% at first we take all frequencies from 1 to 80
idealSpectrumX2 = zeros( 80, nPoints ) - 40;
freqPoint = zeros( 1, nPoints ) + 40;
for iPoint = 2:4001
  freqPoint( iPoint ) = round( 40 + 12*cos( 4*pi*timeValues( iPoint ) ) );
  % we allow bandwidth +-1
  idealSpectrumX2( freqPoint( iPoint ) - 1:freqPoint( iPoint ) + 1, iPoint ) = 0;
end

realFreq        = round( estFreq{ 2 } );
idealSpectrumX1 = idealSpectrumX1( realFreq, : );
idealSpectrumX2 = idealSpectrumX2( realFreq, : );
subplot( 5, 4, plotIndices( nPlot ) );
nPlot = nPlot + 1;
imagesc( timeValues, realFreq, idealSpectrumX1 );
colormap parula
axis xy; % flip axis
xlim( plotXlim );
xlabel( 'Time [s]' );
ylabel( 'Freq [Hz]' );
title( '(I) Ideal spectrum' );
set( gca, 'FontSize', 24 );

caxis( colorbarLim );
subplot( 5, 4, plotIndices( nPlot ) );
imagesc( timeValues, realFreq, idealSpectrumX2 );
axis xy; % flip axis
caxis( colorbarLim );
xlim( plotXlim );
xlabel( 'Time [s]' );
set( gca, 'YTickLabel', [] );
set( gca, 'FontSize', 24 );
hc = colorbar;
title( hc, 'dB/Hz' );

% test how spectra differences from the ideal spectrum look like
figure;
tlbxLabels = {'Brainstorm','Chronux', 'Elephant', ...
 '\begin{tabular}{c} FieldTrip \\ dpss \end{tabular}', ...
 '\begin{tabular}{c} FieldTrip \\ Hanning \end{tabular}', ...
 '\begin{tabular}{c} FieldTrip \\ Morlet \end{tabular}', ...
 '\begin{tabular}{c} MATLAB \\ FFT \end{tabular}', ...
 '\begin{tabular}{c} MATLAB \\ Morlet \end{tabular}'  };
for iSpectrum = 1:16
  subplot( 4, 4, iSpectrum );
  phaseShift = 0;
  if ( iSpectrum == 2 || iSpectrum == 7 || iSpectrum == 8 || ...
      iSpectrum == 10 || iSpectrum == 15 || iSpectrum == 16 )
    phaseShift = 256;
  end
  if ( iSpectrum < 9 )
    temp = estSpectra{ iSpectrum }( 3:35, 1000 - phaseShift:3000 - phaseShift ) - ...
      idealSpectrumX1( 3:35, 1000:3000 );
  else
    temp = estSpectra{ iSpectrum }( 3:35, 1000 - phaseShift:3000 - phaseShift ) - ...
      idealSpectrumX2( 3:35, 1000:3000 );
  end
  imagesc( abs( temp ) );
  axis xy; % flip axis
  colormap parula
  caxis( [ 0 40 ] );
  if ( iSpectrum < 9 )
    title( tlbxLabels{ iSpectrum }, 'Interpreter', 'Latex' );
  else
    title( tlbxLabels{ iSpectrum - 8 }, 'Interpreter', 'Latex' );
  end
  set( gca, 'FontSize', 24 );
end
colorbar;

% compare quantitatevly estimated spectra with ideal one
MSE       = zeros( 2, 16 );
corr2D = zeros( 2, 16 );
% 1 - without noise; 2 - with noise
for iSpectrum = 1:16
  pntsInt = { 1000:2000, 2001:3000 };
  phaseShift = 0;
  % for MATLAB and Chronux there is phase shift 256 points due to no
  % zero-padding
  if ( iSpectrum == 2 || iSpectrum == 7 || iSpectrum == 8 || iSpectrum == 10 )
    phaseShift = 256;
  end
  if ( iSpectrum < 9 )
    idealSpectrum = idealSpectrumX1;
  else
    idealSpectrum = idealSpectrumX2;
  end
  cnt = [ 0 0 ];
  % iInt for the first (stable) and the second (modulated) half of the signal
  for iInt = 1:2
    for iPoint = pntsInt{ iInt }
      cnt( iInt ) = 1;
      for iFreq = 4:39
        temp = ( estSpectra{ iSpectrum }( iFreq, iPoint - phaseShift ) - ...
                                        idealSpectrum( iFreq, iPoint ) ).^2;
        if ( ~isnan( temp ) )
          MSE( iInt, iSpectrum ) =  MSE( iInt, iSpectrum ) + temp;
          cnt( iInt ) = cnt( iInt ) + 1;
        end
      end
    end
    corr2D( iInt, iSpectrum ) = ...
     corr2( estSpectra{ iSpectrum }( 5:39, pntsInt{ iInt } - phaseShift ), ...
                      idealSpectrum( 5:39, pntsInt{ iInt } ) );
  end
  MSE( 1, iSpectrum ) = MSE( 1, iSpectrum )/cnt( 1 );
  MSE( 2, iSpectrum ) = MSE( 2, iSpectrum )/cnt( 2 );
end
newBlue    = [ 0      0.4470 0.7410 ];
newRed     = [ 0.8500 0.3250 0.0980 ];
newYellow  = [ 0.9290 0.6940 0.1250 ];
newViolet  = [ 0.4940 0.1840 0.5560 ];

figure;
subplot( 2, 1, 1 );
hBar = bar( [ MSE( 1, 1 ) MSE( 2, 1 )  MSE( 1, 9 )  MSE( 2, 9 ); ...
              MSE( 1, 2 ) MSE( 2, 2 )  MSE( 1, 10 ) MSE( 2, 10 ); ...
              MSE( 1, 3 ) MSE( 2, 3 )  MSE( 1, 11 ) MSE( 2, 11 ); ...
              MSE( 1, 4 ) MSE( 2, 4 )  MSE( 1, 12 ) MSE( 2, 12 ); ...
              MSE( 1, 5 ) MSE( 2, 5 )  MSE( 1, 13 ) MSE( 2, 13 ); ...
              MSE( 1, 6 ) MSE( 2, 6 )  MSE( 1, 14 ) MSE( 2, 14 ); ...
              MSE( 1, 7 ) MSE( 2, 7 )  MSE( 1, 15 ) MSE( 2, 15 ); ...
              MSE( 1, 8 ) MSE( 2, 8 )  MSE( 1, 16 ) MSE( 2, 16 ) ] ); 
hBar( 1 ).FaceColor = newBlue;
hBar( 2 ).FaceColor = newRed;
hBar( 3 ).FaceColor = newYellow;
hBar( 4 ).FaceColor = newViolet;
grid on;
set( gca, 'XTickLabel', tlbxLabels, 'TickLabelInterpreter', 'Latex' );
ylabel( '(A) MSE' );
legend( 'x_1', 'x_2', 'x_1 with noise', 'x_2 with noise' );
ylim( [ 0 6.5*10^5 ] );
set( gca, 'FontSize', 26 );

subplot( 2, 1, 2 );
hBar = bar( [ corr2D( 1, 1 ) corr2D( 2, 1 ) corr2D( 1, 9 )  corr2D( 2, 9 ); ...
          corr2D( 1, 2 ) corr2D( 2, 2 ) corr2D( 1, 10 ) corr2D( 2, 10 ); ...
          corr2D( 1, 3 ) corr2D( 2, 3 ) corr2D( 1, 11 ) corr2D( 2, 11 ); ...
          corr2D( 1, 4 ) corr2D( 2, 4 ) corr2D( 1, 12 ) corr2D( 2, 12 ); ...
          corr2D( 1, 5 ) corr2D( 2, 5 ) corr2D( 1, 13 ) corr2D( 2, 13 ); 
          corr2D( 1, 6 ) corr2D( 2, 6 ) corr2D( 1, 14 ) corr2D( 2, 14 ); ...
          corr2D( 1, 7 ) corr2D( 2, 7 ) corr2D( 1, 15 ) corr2D( 2, 15 ); 
          corr2D( 1, 8 ) corr2D( 2, 8 ) corr2D( 1, 16 ) corr2D( 2, 16 ) ] ); 
hBar( 1 ).FaceColor = newBlue;
hBar( 2 ).FaceColor = newRed;
hBar( 3 ).FaceColor = newYellow;
hBar( 4 ).FaceColor = newViolet;
grid on;
set( gca, 'XTickLabel', tlbxLabels, 'TickLabelInterpreter', 'Latex' );
ylabel( '(B) 2D correlation coefficient' );
ylim( [ 0.0 1.0 ] );
set( gca, 'FontSize', 26 );

%% 4.1 Connectivity measures: coherence, Granger causality, 
% directed transfer function, partial (Brainstorm, Chronux, FieldTrip)

clear;
nRuns   = 1;   % increase this variable to average computing time over runs
nTrials = 500;
fSample = 200;
% generate multivariate autoregresive model of order 2 in FieldTrip
% this code is according to the FieldTrip tutorial (accessed on 05.04.2019):
% http://www.fieldtriptoolbox.org/tutorial/connectivity/
cfg             = [];
cfg.ntrials     = nTrials;
cfg.triallength = 4; % in seconds
cfg.fsample     = fSample;
cfg.nsignal     = 3;
cfg.method      = 'ar';
cfg.params( :, :, 1 ) = [  0.8 0.0 0.0; 0.0  0.9 0.5; 0.4 0.0  0.5 ];
cfg.params( :, :, 2 ) = [ -0.5 0.0 0.0; 0.0 -0.8 0.0; 0.0 0.0 -0.2 ];
cfg.noisecov          = [  0.3 0.0 0.0; 0.0  1.0 0.0; 0.0 0.0  0.2 ];
FTdata                = ft_connectivitysimulation( cfg );

if ( 0 )% set to 1 to test in the presence of observational noise
  for iTrial = 1:nTrials
    for iChannel = 1:3
      dataFieldTrip.trial{ iTrial }( iChannel, : ) = ...
        dataFieldTrip.trial{ iTrial }( iChannel, : ) + randn( 1, 800 );
    end
  end
end

idxCOH = [ 1 2; 1 3; 2 3 ];
idxGC  = [ 1 2; 1 3; 2 3; 2 1; 3 1; 3 2 ];
% multivariate analysis with FieldTrip
cfg1        = [];
cfg1.order  = 5;
cfg1.toolbox = 'bsmart';
cfg2        = [];
cfg2.method = 'mvar';
cfg3        = [];
cfg3.method = 'coh';

% compute coherence with FieldTrip with AR model
tic; % measure computing time
for iRun = 1:nRuns
  mdata  = ft_mvaranalysis( cfg1, FTdata );
  FT_FREQ = ft_freqanalysis( cfg2, mdata );
  FT_COH  = ft_connectivityanalysis( cfg3, FT_FREQ );
end
% square coherence values to compare with those by Brainstorm
FT_COH.cohspctrm = FT_COH.cohspctrm.^2;
FT_CohTime = toc/nRuns;

% one can compute coherence using mtmfft for spectrum estimation: same results
%{
cfg           = [];
cfg.method    = 'mtmfft';
cfg.taper     = 'dpss';
cfg.output    = 'fourier';
cfg.tapsmofrq = 2;
tic; % measure computing time
for iRun = 1:nRuns
  FT_FREQ2 = ft_freqanalysis( cfg, dataFieldTrip );
  FT_COH2  = ft_connectivityanalysis( cfg3, freq1FieldTrip );
end
FT_CohTime2 = toc/nRuns;
%}

% compute coherence with Chronux
chData = cell( 1, 3 );
for iDir = 1:3
  chData{ iDir }( 1, : ) = FTdata.trial{ iDir }( 1, : );
end
for iTrial = 2:nTrials 
  for iDir = 1:3
    chData{ iDir }( iTrial, : ) = FTdata.trial{ iTrial }( iDir, : );
  end
end

movingWin       = [ 0.80 0.05 ]; % moving window and step in seconds
params          = [];
params.Fs       = fSample;       % sampling rate
params.tapers   = [ 3 5 ];       % tapers parameters
params.trialave = 1;
params.err      = [ 1 0.05 ];
chronuxCohTime  = zeros( 1, 3 );
for iDir = 1:3
  tic;
  for iRun = 1:nRuns
    [ temp, phi, S12, S1, S2, t, freqChronux, Cerr12, ~ ] = ...
       cohgramc( chData{ idxCOH( iDir, 1 ) }', chData{ idxCOH( iDir, 2 ) }', ...
                                                        movingWin, params );
  end
  chronuxCohTime( iDir ) = toc/nRuns;
  % suqare coherence values to compare with those by Brainstorm
  cohChronux( iDir, : )  = mean( temp ).^2;
end
                    
% compute coherence with Brainstorm for concatenated signal
data_concat = cell( 1, 3 );
for iTrial = 1:nTrials
  for iSig = 1:3
    data_concat{ iSig } = [ data_concat{ iSig } ( chData{ iSig }( iTrial, : ) ) ];
  end
end

maxFreqRes = 1;
overlap    = 0.5;
BS_CohTime = zeros( 1, 3 );
for iDir = 1:3
  tic;
  for iRun = 1:nRuns
    [ temp, freqBS1, ~, ~, ~, ~ ] = bst_cohn( data_concat{ idxCOH( iDir, 1 ) }, ...
        data_concat{ idxCOH( iDir, 2 ) }, fSample, maxFreqRes, overlap, ...
                                                    'mscohere', 0, [], [] ); 
  end
  BS_CohTime( iDir ) = toc/nRuns;
  BS_COH( iDir, : )  = squeeze( temp );
  freqBS1 = squeeze( freqBS1 );
  disp( [ 'Computing coh with Brainstorm, ' num2str( iDir ) ' from ' '3' ] );
end
                                
% compute Granger causality with FieldTrip
cfg        = [];
cfg.method = 'granger';
tic;
for iRun = 1:nRuns
  GC_FT = ft_connectivityanalysis( cfg, FT_FREQ );
end
FT_GC_Time = toc/nRuns;

% compute Directed Transfer Function with FieldTrip
cfg        = [];
cfg.method = 'dtf';
tic;
for iRun = 1:nRuns
  DTF_FT = ft_connectivityanalysis( cfg, FT_FREQ );
end
FT_DTF_Time = toc/nRuns;

% compute partial directed coherence with FieldTrip
cfg        = [];
cfg.method = 'pdc';
tic;
for iRun = 1:nRuns
  PDC_FT = ft_connectivityanalysis( cfg, FT_FREQ );
end
FT_PDC_Time = toc/nRuns;

% compute Granger causality with Brainstorm
inputs         = [];
inputs.freq    = 0:1:100;
inputs.nTrials = 500;
order          = 10;
BS_GC_Time     = zeros( 1, 6 );
for iDir = 1:6
  tic;
  for iRun = 1:nRuns
    [ temp, freqBS2, ~ ] = bst_granger_spectral( data_concat{ idxGC( iDir, 1 ) }, ...
               data_concat{ idxGC( iDir, 2 ) }, fSample, order, inputs );
  end
  BS_GC_Time( iDir ) = toc/nRuns;
  GC_BS{ idxGC( iDir, 1 ), idxGC( iDir, 2 ) } = squeeze( temp );
  freqBS2 = squeeze( freqBS2 );
end

% plotting connectivity analysis results
fSize  = 26;
lWidth = 4;
figure;
subLetters = {'(A)', '(B)', '(C)'};
letters = { '$X\longleftrightarrow Y$', '$X\longleftrightarrow Z$', ...
               '$Y \longleftrightarrow Z$' };
cViolet = [ 0.4940 0.1840 0.5560 ];   
cGreen  = [ 0.4660 0.6740 0.1880 ];
cYellow = [ 0.9290 0.6940 0.1250 ];
cRed    = [ 0.8500 0.3250 0.0980 ];

for iDir = 1:3
  subplot( 3, 3, iDir );
  plot( 0:100/127:100, BS_COH( iDir, : ), 'LineWidth', lWidth ); 
  hold on;
  plot( freqChronux, cohChronux( iDir, : ), '--', 'LineWidth', lWidth, ...
      'color', cYellow );
  plot( FT_FREQ.freq, ...
    squeeze( FT_COH.cohspctrm( idxCOH( iDir, 1 ), idxCOH( iDir, 2 ), : ) ), ...
                       '--', 'LineWidth', lWidth, 'color', cRed );                                  
  legend( [ 'Brainstorm, ' num2str( BS_CohTime( iDir ), '%.2f' ) 's' ], ...
          [ 'Chronux, ' num2str( chronuxCohTime( iDir ), '%.2f' ) 's' ], ...
          [ 'FieldTrip, ' num2str( FT_CohTime/3, '%.2f' ) 's' ] );
  title( [ subLetters{ iDir } ' Coherence ' letters{ iDir } ], ...
                                                  'Interpreter', 'Latex' );
  grid on;
  ylim( [ 0 0.7 ] );
  set( gca, 'FontSize', fSize );
end

letters = { '$X \longrightarrow Y$', '$X \longrightarrow Z$', ...
            '$Y \longrightarrow Z$', '$Y \longrightarrow X$', ...
            '$Z \longrightarrow X$', '$Z \longrightarrow Y$' };
subletters = {'(D)','(E)','(F)','(G)','(H)','(I)'};          
% ! for Brainstorm the direction is reversed ! %
for iDir = 1:6
  subplot( 3, 3, iDir + 3 );
  plot( GC_BS{ idxGC( iDir, 2 ), idxGC( iDir, 1 ) }, 'LineWidth', lWidth ); 
  hold on;
  plot( GC_FT.freq, squeeze( GC_FT.grangerspctrm( idxGC( iDir, 1 ), ...
                        idxGC( iDir, 2 ), : ) ), 'LineWidth', lWidth );           
  plot( DTF_FT.freq, squeeze( DTF_FT.dtfspctrm( idxGC( iDir, 1 ), ...
         idxGC( iDir, 2 ), : ) ), 'LineWidth', lWidth, 'color', cViolet );
  plot( PDC_FT.freq, squeeze( PDC_FT.pdcspctrm( idxGC( iDir, 1 ), ...
         idxGC( iDir, 2 ), : ) ), '--', 'LineWidth', lWidth, 'color', cGreen );
  legend( [ 'Brainstorm, GC, ' num2str( BS_GC_Time( iDir ), '%.2f' ) 's' ], ...
          [ 'FieldTrip, GC, ' num2str( FT_GC_Time/6, '%.2f' ) 's' ], ...
          [ 'FieldTrip, DTF, ' num2str( FT_DTF_Time/6, '%.2f' ) 's' ], ...
          [ 'FieldTrip, PDC, ' num2str( FT_PDC_Time/6, '%.2f' ) 's' ] );
  title( [ subletters{iDir} ' GC, DTF, PDC ' letters{ iDir } ], ...
                                                  'Interpreter', 'Latex' );
  grid on;
  ylim( [ 0.0 1.5 ] );
  if ( iDir > 3 )
    xlabel( 'Freq [Hz]' ); 
  end
  set( gca, 'FontSize', fSize );
end

%% 4.2 Unique tools: joint peri-stimulus time histogram (FieldTrip)

clear
load( 'PerichReachData.mat' );
nTrials        = 498;
unitsSelection = [ 6 14 ];
timeSegment    = [ 0.0 1.0 ]; 
% convert data to FieldTrip format (take only first second)
[ spikeData, newNumbers ] = ...
    convertToFieldTrip( Data, 'M1', unitsSelection, nTrials, timeSegment );

cfg         = [];
cfg.latency = timeSegment; 
cfg.trials  = find( newNumbers == 2 );
[ sdf ]     = ft_spikedensity( cfg, spikeData );
 
% compute the joint psth
cfg               = [];
cfg.normalization = 'no';
cfg.channelcmb    = spikeData.label( 1:2 );
cfg.method        = 'jpsth';
jpsth             = ft_spike_jpsth( cfg, sdf );
 
cfg.method = 'shiftpredictor';
jpsthShuff = ft_spike_jpsth( cfg, sdf );
 
% subtract the predictor
jpsthSubtr       = jpsth;
jpsthSubtr.jpsth = jpsth.jpsth - jpsthShuff.shiftpredictor;

cfg = [];
cfg.latency  = timeSegment;
cfg.colormap = parula; 
figure;
subplot( 1, 3, 1 );
ft_spike_plot_jpsth( cfg, jpsth );
title( '(A) JPSTH' );
set( gca, 'FontSize', 24 );
subplot( 1, 3, 2 );
ft_spike_plot_jpsth( cfg, jpsthShuff );
title( '(B) JPSTH shuffled' );
set( gca, 'FontSize', 24 );
subplot( 1, 3, 3 );
ft_spike_plot_jpsth( cfg, jpsthSubtr );
title( '(C) JPSTH subtracted' );
set( gca, 'FontSize', 24 );

%% 5 Dimensionality reduction toolboxes

%% 5.1 Gaussian-Process Factor Analysis (DataHigh)
clear
load( 'PerichReachData.mat' );
nTrials        = 498;
nPoints        = 1000;
unitsSelection = 1:67;
for iUnit = 1:length( unitsSelection )
  cnt = 1;
  % we take only second reaches
  for iTrial = 2:4:nTrials
      if ( size( Data.neural_data_M1{ iTrial }( unitsSelection( iUnit ), : ), 2 ) > 1000 )
        % we take first second
        D( cnt ).data( iUnit, 1:nPoints ) = ...
          Data.neural_data_M1{ iTrial }( unitsSelection( iUnit ), 1:1000 );
        cnt = cnt + 1;
      end
  end
end

DataHigh( D, 'DimReduce' );
DataHigh( D ); % visualize

%% 5.2 Tensor component analysis (FieldTrip, tensor-demo)
clear
load( 'PerichReachData.mat' );
unitsSelection = 1:49;
nTrials        = 498;
timeSegment    = [ 0.0 1.0 ]; % in seconds
% convert data to FieldTrip format
[ spikeData, newNumbers ] = ...
  convertToFieldTrip( Data, 'M1', unitsSelection, nTrials, timeSegment );

cfg            = [];
cfg.binsize    = 0.05; % in seconds
cfg.latency    = timeSegment;
cfg.outputunit = 'rate';
cfg.trials     = find( newNumbers == 2 );
psthFieldTrip  = ft_spike_psth( cfg, spikeData );

cfg         = [];
cfg.timwin  = [ -0.05 0.05 ]; % in seconds
cfg.latency = timeSegment;    % in seconds
cfg.fsample = 1000;
cfg.winfunc = 'gauss';
[ avgSpikeDensities, spikeDensities ] = ft_spikedensity( cfg, spikeData ); 

cfg              = [];
cfg.topplotfunc  = 'line'; % plot as a line
cfg.spikechannel = spikeData.label( [ 1 2 3 4 5 ] );
cfg.latency      = timeSegment; % in seconds
cfg.linewidth    = 4;

% visualize first 5 units
figure;
ft_spike_plot_raster( cfg, spikeData, avgSpikeDensities ); 
set( gca, 'fontSize', 24 );
title( 'FieldTrip: smoothed PSTH and raster plot' );

% convert data for TCA, now we will re-arrange trials
nTrials = numel( find( newNumbers == 2 ) );
[ nUnits, trialLength ] = size( spikeDensities.trial{ 1 } );
TCAdata = zeros( nUnits, trialLength, nTrials );
for iUnit = 1:nUnits
  for iPos = 1:trialLength
    cnt = 1;
    % we take only reaches for the second target
    for iTrial = find( newNumbers == 2 )
      TCAdata( iUnit, iPos, cnt ) = spikeDensities.trial{ iTrial }( iUnit, iPos );
      cnt = cnt + 1;
    end
  end
end

% apply TCA with N components
nComponents = 3;
model = cp_als( tensor( TCAdata ), nComponents ); % fit CP model with N components
viz_ktensor( model ,'Plottype', { 'bar', 'line', 'scatter' }, ...
                    'Modetitles', {'neurons', 'time', 'trials' } );                 

%% 5.3 demixed Principal Component Analysis (dPCA)
clear
load( 'PerichReachData.mat' );
unitsSelection = 1:49;
nTrials        = 498;
timeSegment    = [ 0.0 1.0 ]; % in seconds
% convert data to FieldTrip format
[ spikeData, newNumbers ] = ...
    convertToFieldTrip( Data, 'M1', unitsSelection, nTrials, timeSegment );

nConditions = 4;
nPoints     = 100;
nUnits      = numel( spikeData.label );
dpcaData    = zeros( nUnits, nConditions, nPoints );
for iCondition = 1:4
  cfg            = [];
  cfg.binsize    = 0.01; % in seconds
  cfg.latency    = timeSegment;
  cfg.outputunit = 'rate';
  cfg.trials     = find( newNumbers == iCondition );
  psthFieldTrip           = ft_spike_psth( cfg, spikeData );
  dpcaData( 1:nUnits, iCondition, 1:nPoints ) = psthFieldTrip.avg;
end

[ W, V, whichMarg ] = dpca( dpcaData, 3 );
% computing explained variance
combinedParams = { {1, [1 2]}, {2} };
explVar        = dpca_explainedVariance( dpcaData, W, W, 'combinedParams', combinedParams );
% a bit more informative plotting
margNames   = { 'Stimulus', 'Condition-independent'};
margColours = [23 100 171; 187 20 25; 150 150 150; 114 97 171]/256;
dpca_plot( dpcaData, W, W, @dpca_plot_default, 'explainedVar', explVar, ...
  'marginalizationNames', margNames, 'marginalizationColours', margColours );

%% Appendix A.1: spectogram of averaged trials (MATLAB, Chronux, FieldTrip)

clear
% LFP data from https://datadryad.org/resource/doi:10.5061/dryad.p631f
load( 'monkey_example_data_v1.mat' );
movingWindow     = 512; % in points: 512ms = 512 points
windowStep       = 1;  % in points: 50ms = 50 points
freqOfInterest   = 24.0:2.0:80.0;
fSample          = 1000; % sampling frequency
minDb            = -20;
colorbarLim      = [ minDb 0 ];
morletFTwidth    = 10; % width of wavelet in number of cycles
ftTaperSmoothing = 3;
nRuns            = 10; % increase nRuns to average computing times over more runs
plotXlim         = [ -0.7 0.5 ];
lfpTimeSegment   = 1:1800; % in time points

iPlot = 1;
figure;
pIndexes = [ 1 3 5 7 9 2 4 6 8 10 ];
for contrastLevel = [ 6 8 ]
  lfpData        = monkey_data{ contrastLevel };
  for iTrial = 1:31
    dataValues( iTrial, : ) = lfpData.trial{ iTrial }( lfpTimeSegment );
  end
  timeSegment    = [ -1.0 0.8 ]; % in seconds
  timeValues     = lfpData.time{ 1 }( lfpTimeSegment );

  % Chronux multi-taper time-frequency transform
  subplot( 5, 2, pIndexes( iPlot ) );
  iPlot = iPlot + 1;
  tbwProduct    = 2;
  nTapers       = 3;
  params.tapers = [ tbwProduct nTapers ];   % Taper parameters
  params.fpass  = [ freqOfInterest( 1 ) freqOfInterest( end ) ];
  params.Fs     = fSample;    % Sampling Rate
  params.pad    = 2; % padding type
  params.trialave = 1;
  % loop to measure computing time
  tic;
  for iRun = 1:nRuns
    [ spectrumValues, cTimeValues, freqValues ] = ...
       mtspecgramc( dataValues', [ movingWindow windowStep ]/fSample, params );
  end
  specTime( 2 ) = toc/nRuns;
  spectrumValues = spectrumValues/( max( max( spectrumValues ) ) );
  spectrumValues = 10*log10( spectrumValues );
  spectrumValues( spectrumValues < minDb ) = minDb;
  imagesc( ( cTimeValues - 1.0 )', freqValues', spectrumValues' );
  colormap parula
  xlim( plotXlim );
  set( gca, 'XTick', [] );
  caxis( colorbarLim );
  set( gca, 'FontSize', 24 );
  hc = colorbar;
  title( hc, 'dB/Hz' );
  if ( contrastLevel == 6 )
    ylabel( 'Freq [Hz]' );
  else
    set( gca, 'YTick', [] );
  end
  set( gca, 'YDir', 'normal' )
  title( [ 'Chronux: mtspecgramc, ' num2str( specTime( 2 )/nRuns, '%.2f' ) 's' ] );

  % FieldTrip multitaper time-frequency transform with a Hanning window
  subplot( 5, 2, pIndexes( iPlot ) );
  iPlot = iPlot + 1;
  cfg           = [];
  cfg.foi       = freqOfInterest; % Freq Of Interest - analysis in steps of 0.2 Hz 
  cfg.method    = 'mtmconvol';    % time-frequency analysis using Morlet waveforms
  cfg.output    = 'pow';
  cfg.taper     = 'hanning';
  % length of sliding time window in seconds
  cfg.t_ftimwin = ones( length( cfg.foi ), 1 ).*movingWindow/fSample; 
  % times on which analysis windows should be centered
  cfg.toi       = timeSegment( 1 ):windowStep/fSample:timeSegment( 2 );
  % loop to measure computing time
  tic;
  for iRun = 1:nRuns
    spectrumValues = ft_freqanalysis( cfg, lfpData );
  end
  specTime( 3 ) = toc/nRuns;
  temp = spectrumValues.powspctrm/max( max( spectrumValues.powspctrm ) );
  spectrumValues.powspctrm = 10*log10(temp);
  spectrumValues.powspctrm( spectrumValues.powspctrm < minDb ) = minDb;
  ft_singleplotTFR( [], spectrumValues );
  caxis( colorbarLim );
  xlim( plotXlim );
  set( gca, 'XTick', [] );
  if ( contrastLevel == 6 )
    ylabel( 'Freq [Hz]' );
  else
    set( gca, 'YTick', [] );
  end
  title( [ 'FieldTrip: mtmconvol (Hanning), ' ...
                          num2str( specTime( 3 )/nRuns, '%.2f' ) 's'] );
  set( gca, 'FontSize', 24 );

  % Fieldtrip multi-taper time-frequency transform with Slepian seuqences
  subplot( 5, 2, pIndexes( iPlot ) );
  iPlot = iPlot + 1;
  cfg           = [];
  cfg.foi       = freqOfInterest; % frequencies of interest 
  cfg.method    = 'mtmconvol';    % multitapers
  cfg.output    = 'pow';
  cfg.taper     = 'dpss';         % with Slepian sequences
  cfg.tapsmofrq = ftTaperSmoothing; % amount of spectral smoothing
  % length of sliding time window in seconds
  cfg.t_ftimwin = ones( length( cfg.foi ), 1 ).*movingWindow/fSample; 
  % times (in seconds) on which analysis windows should be centered
  cfg.toi       = timeSegment( 1 ):windowStep/fSample:timeSegment( 2 );
  tic;
  for iRun = 1:nRuns % loop to measure computing time
    spectrumValues = ft_freqanalysis( cfg, lfpData );
  end
  specTime( 4 ) = toc/nRuns;
  temp = spectrumValues.powspctrm/max( max( spectrumValues.powspctrm ) );
  spectrumValues.powspctrm = 10*log10( temp );
  spectrumValues.powspctrm( spectrumValues.powspctrm < minDb ) = minDb;
  ft_singleplotTFR( [], spectrumValues );
  set( gca, 'XTick', [] );
  if ( contrastLevel == 6 )
    ylabel( 'Freq [Hz]' );
  else
    set( gca, 'YTick', [] );
  end
  caxis( colorbarLim );
  xlim( plotXlim );
  title( [ 'FieldTrip: mtmconvol (dpss), ' ...
                            num2str( specTime( 4 )/nRuns, '%.2f' ) 's' ] );
  set( gca, 'FontSize', 24 );

  % FieldTrip Morlet wavelet transform 
  subplot( 5, 2, pIndexes( iPlot ) );
  iPlot = iPlot + 1;
  cfg           = [];
  cfg.foi       = freqOfInterest; % frequencies of interest 
  cfg.method    = 'wavelet';      % Morlet waveforms
  cfg.output    = 'pow';
  % times on which analysis windows should be centered
  cfg.toi       = timeSegment( 1 ):windowStep/fSample:timeSegment( 2 );
  % standard parameters
  cfg.width     = morletFTwidth;
  
  tic;
  for iRun = 1:nRuns % loop to measure computing time
    spectrumValues = ft_freqanalysis( cfg, lfpData );
  end
  specTime( 7 ) = toc/nRuns;
  temp = spectrumValues.powspctrm/max( max( spectrumValues.powspctrm ) );
  spectrumValues.powspctrm = 10*log10( temp );
  spectrumValues.powspctrm( spectrumValues.powspctrm < minDb ) = minDb;
  ft_singleplotTFR( [], spectrumValues );
  caxis( colorbarLim );
  xlim( plotXlim );
  set( gca, 'XTick', [] );
  if ( contrastLevel == 6 )
    ylabel( 'Freq [Hz]' );
  else
    set( gca, 'YTick', [] );
  end
  title( [ 'FieldTrip: Morlet wavelet, ' ...
                            num2str( specTime( 7 )/nRuns, '%.2f' ) 's' ] );
  set( gca, 'FontSize', 24 );

  % FieldTrip Morlet wavelets
  subplot( 5, 2, pIndexes( iPlot ) );
  iPlot = iPlot + 1;
  cfg           = [];
  cfg.foi       = freqOfInterest; 
  cfg.method    = 'tfr';    % wavelets
  cfg.output    = 'pow';
  % times on which analysis windows should be centered
  cfg.toi       = timeSegment( 1 ):windowStep/fSample:timeSegment( 2 );
  cfg.width     = morletFTwidth; % wavelet width in number of cycles
  tic;
  for iRun = 1:nRuns % loop to measure computing time
    spectrumValues = ft_freqanalysis( cfg, lfpData );
  end
  specTime( 8 ) = toc/nRuns;
  temp = spectrumValues.powspctrm/max( max( spectrumValues.powspctrm ) );
  spectrumValues.powspctrm = 10*log10( temp );
  spectrumValues.powspctrm( spectrumValues.powspctrm == -Inf ) = NaN;
  spectrumValues.powspctrm( spectrumValues.powspctrm < minDb ) = minDb;
  ft_singleplotTFR( [], spectrumValues );
  caxis( colorbarLim );
  xlim( plotXlim );
  xlabel( 'Time [s]' );
  if ( contrastLevel == 6 )
    ylabel( 'Freq [Hz]' );
  else
    set( gca, 'YTick', [] );
  end
  title( [ 'FieldTrip: tfr (wavelet), ' ...
                            num2str( specTime( 8 )/nRuns, '%.2f' ) 's' ] );
  set( gca, 'FontSize', 24 );
end